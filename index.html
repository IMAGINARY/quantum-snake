<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Quantum Snake</title>
    <script src="https://unpkg.com/quantum-circuit@^0.9.224/dist/quantum-circuit.min.js"></script>
    <script>
      const Directions = {
        UP: "UP",
        DOWN: "DOWN",
        LEFT: "LEFT",
        RIGHT: "RIGHT",
      };

      const BOARD_WIDTH = 50;
      const BOARD_HEIGHT = 40;

      const MIN_LENGTH = 2;
      const BLOCK_SIZE = 15;

      class Game {
        constructor(canvasElement, statusElement) {
          this.statusElement = statusElement;

          this.canvasElement = canvasElement;
          this.canvasElement.width = BOARD_WIDTH * BLOCK_SIZE;
          this.canvasElement.height = BOARD_HEIGHT * BLOCK_SIZE;

          this.ctx = canvasElement.getContext("2d");
          this.shouldPlay = false;
          this.lastTimestampMs = 0;
          this.durationSinceLastStepMs = 0;

          this.blocksPerSecond = 10;

          this.direction = Directions.RIGHT;
          this.directionCandidate = this.direction;
          this.snake = new Snake();

          this.itemManager = new ItemManager(5, 5, this.snake.body);

          const keyDirectionMap = {
            ArrowUp: Directions.UP,
            ArrowDown: Directions.DOWN,
            ArrowLeft: Directions.LEFT,
            ArrowRight: Directions.RIGHT,
          };

          const keySpeedMap = {
            "+": +1,
            "-": -1,
          };

          document.addEventListener("keydown", (event) => {
            this.directionCandidate =
              keyDirectionMap[event.key] ?? this.directionCandidate;

            this.blocksPerSecond = Math.max(1, this.blocksPerSecond + (keySpeedMap[event.key] ?? 0));
          });
        }

        start() {
          this.shouldPlay = true;
          requestAnimationFrame(this.startAnimation.bind(this));
        }

        startAnimation(timestampMs) {
          this.lastTimestampMs = timestampMs;
          requestAnimationFrame(this.animate.bind(this));
        }

        animate(timestampMs) {
          if (!this.shouldPlay) return;

          const durationMs = timestampMs - this.lastTimestampMs;
          this.updateState(durationMs);
          this.render();
          this.lastTimestampMs = timestampMs;

          if (this.shouldPlay) requestAnimationFrame(this.animate.bind(this));
        }

        updateState(durationMs) {
          this.durationSinceLastStepMs += durationMs;
          if (this.durationSinceLastStepMs >= 1000 / this.blocksPerSecond) {
            this.updateDirection();
            let steps = Math.floor(
              this.durationSinceLastStepMs / (1000 / this.blocksPerSecond)
            );
            while (steps > 0) {
              // Move snake
              this.snake.move(this.direction);
              this.durationSinceLastStepMs -= 1000 / this.blocksPerSecond;
              steps -= 1;

              // Handle collision of the snake with itself
              const selfCollisionIndex = this.collide(
                this.snake.body,
                this.snake.body[this.snake.body.length - 1]
              );
              if (selfCollisionIndex === this.snake.body.length - 1) {
                // Ignore collision of the head with itself
              } else {
                // Snake is dead. Game over.
                this.snake.dead = true;
                this.shouldPlay = false;
                break;
              }

              // Handle collision of the snake with items
              const snakeHead = this.snake.body[this.snake.body.length - 1];
              const activatedItem = this.itemManager.activate(
                snakeHead.x,
                snakeHead.y
              );
              if (activatedItem === null) {
                // No item was activated
              } else {
                console.log(activatedItem);
                if (activatedItem === "grow") {
                  this.snake.grow(1);
                } else if (activatedItem === "shrink") {
                  this.snake.shrink(1);
                }
              }
            }

            this.statusElement.innerText = `Snake length: ${this.snake.body.length}\nProbabilities: ${this.itemManager.quantumCircuit.probabilities()}\nQubit state:\n${this.itemManager.quantumCircuit.stateAsString()}`;
          }
        }

        updateDirection() {
          // snake can't turn 180 degrees
          if (
            this.directionCandidate === Directions.UP &&
            this.direction !== Directions.DOWN
          ) {
            this.direction = this.directionCandidate;
          } else if (
            this.directionCandidate === Directions.DOWN &&
            this.direction !== Directions.UP
          ) {
            this.direction = this.directionCandidate;
          } else if (
            this.directionCandidate === Directions.LEFT &&
            this.direction !== Directions.RIGHT
          ) {
            this.direction = this.directionCandidate;
          } else if (
            this.directionCandidate === Directions.RIGHT &&
            this.direction !== Directions.LEFT
          ) {
            this.direction = this.directionCandidate;
          }
        }

        collide(listOfPoints, point) {
          return listOfPoints.findIndex(
            (p) => p.x === point.x && p.y === point.y
          );
        }

        render() {
          const ctx = this.ctx;

          ctx.save();
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, this.canvasElement.width, this.canvasElement.height);
          ctx.restore();

          ctx.save();
          this.itemManager.render(ctx);
          ctx.restore();

          ctx.save();
          this.snake.render(ctx);
          ctx.restore();
        }
      }

      class Snake {
        constructor() {
          this.body = [{ x: 0, y: 10 }];
          this.maxLength = MIN_LENGTH;
          this.maxLength = 10;
          this.dead = false;
        }

        move(direction) {
          const head = this.body[this.body.length - 1];
          const newHead = { ...head };

          switch (direction) {
            case Directions.UP:
              newHead.y -= 1;
              break;
            case Directions.DOWN:
              newHead.y += 1;
              break;
            case Directions.LEFT:
              newHead.x -= 1;
              break;
            case Directions.RIGHT:
              newHead.x += 1;
              break;
          }

          newHead.x = (BOARD_WIDTH + newHead.x) % BOARD_WIDTH;
          newHead.y = (BOARD_HEIGHT + newHead.y) % BOARD_HEIGHT;

          this.body.push(newHead);
          this.truncate();
        }

        truncate() {
          if (this.body.length > this.maxLength) {
            const start = this.body.length - this.maxLength;
            const end = this.body.length;
            this.body = this.body.slice(start, end);
          }
        }

        grow(offset) {
          this.maxLength += offset;
        }

        shrink(offset) {
          this.maxLength = Math.max(this.maxLength - offset, MIN_LENGTH);
          this.truncate();
        }

        render(ctx) {
          ctx.lineWidth = BLOCK_SIZE;
          ctx.lineCap = "round";

          const headColor = this.dead ? "red" : "white";
          const tailColor = "grey";

          this.body.forEach(({ x: blockX, y: blockY }, i) => {
            ctx.strokeStyle =
              i === this.body.length - 1 ? headColor : tailColor;
            ctx.beginPath();
            const x = blockX * BLOCK_SIZE + BLOCK_SIZE / 2;
            const y = blockY * BLOCK_SIZE + BLOCK_SIZE / 2;
            ctx.moveTo(x, y);
            ctx.lineTo(x, y);
            ctx.stroke();
          });
        }
      }

      class ItemManager {
        // TODO: snakeBody should not be passed here (it's just used to avoid collisions)
        constructor(numQubits, numGates, snakeBody) {
          this.snakeBody = snakeBody;

          this.quantumCircuit = new QuantumCircuit(numQubits);

          this.qubitPositions = new Array(numQubits)
            .fill(0)
            .map((_, i) => ({ x: 0, y: 0 }));
          this.quantumLogicGates = new Array(numGates)
            .fill(0)
            .map((_, i) => ({ x: 0, y: 0 }));

          this.qubitPositions.forEach((_, i) => this.renewQubit(i));
          this.quantumLogicGates.forEach((_, i) =>
            this.renewQuantumLogicGate(i)
          );
        }

        activate(x, y) {
          const qubitIndex = this.qubitPositions.findIndex(
            (q) => q.x === x && q.y === y
          );
          if (qubitIndex !== -1) {
            // Measure qubit
            const bit = this.quantumCircuit.measure(qubitIndex);

            // Reset qubit to the measured value to update entangled qubits
            this.quantumCircuit.resetQubit(qubitIndex, bit);

            console.log(this.quantumCircuit.stateAsString());
            console.log(this.quantumCircuit.probabilities());

            // Renew the qubit item
            this.renewQubit(qubitIndex);

            // Return "grow" or "shrink" depending on measurement result
            return bit === 0 ? "grow" : "shrink";
          }

          const gateIndex = this.quantumLogicGates.findIndex(
            (g) => g.x === x && g.y === y
          );
          if (gateIndex !== -1) {
            console.log(
              "Applying quantum logic gate",
              this.quantumLogicGates[gateIndex]
            );

            // Clear quantum logic gates of circuit
            this.quantumCircuit.clearGates();

            // Append quantum logic gates to (empty) circuit
            this.quantumCircuit.appendGate(
              this.quantumLogicGates[gateIndex].name,
              this.quantumLogicGates[gateIndex].qubits
            );

            // Run circuit using the current qubit values
            this.quantumCircuit.run(undefined, { continue: true });
            console.log(this.quantumCircuit.stateAsString());
            console.log(this.quantumCircuit.probabilities());

            // Renew the quantum logic gate item
            this.renewQuantumLogicGate(gateIndex);

            return "gate";
          }

          return null;
        }

        renewQubit(qubitIndex) {
          if (qubitIndex < 0 || qubitIndex >= this.qubitPositions.length) {
            return;
          }

          // TODO: Reset qubit to |0>
          // TODO: apply random rotation to qubit (3 random Euler angles)

          // Move qubit to a random free position
          Object.assign(
            this.qubitPositions[qubitIndex],
            this.getRandomFreePosition()
          );
        }

        renewQuantumLogicGate(gateIndex) {
          if (gateIndex < 0 || gateIndex >= this.quantumLogicGates.length) {
            return;
          }

          const gatesNamesWithNumOfQubits = { x: 1, h: 1, cx: 2 };
          const gateNames = Object.keys(gatesNamesWithNumOfQubits);
          const name = gateNames[Math.floor(Math.random() * gateNames.length)];

          const shuffledQubitIndices = this.qubitPositions.map((_, i) => i);
          for (let i = shuffledQubitIndices.length - 1; i > 0; i -= 1) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledQubitIndices[i], shuffledQubitIndices[j]] = [
              shuffledQubitIndices[j],
              shuffledQubitIndices[i],
            ];
          }

          const qubits = shuffledQubitIndices.slice(
            0,
            gatesNamesWithNumOfQubits[name]
          );

          // Move gate to a random free position
          Object.assign(
            this.quantumLogicGates[gateIndex],
            this.getRandomFreePosition(),
            { name, qubits }
          );
        }

        getRandomPosition() {
          return {
            x: Math.floor(Math.random() * BOARD_WIDTH),
            y: Math.floor(Math.random() * BOARD_HEIGHT),
          };
        }

        isFreePosition(x, y) {
          return (
            !this.qubitPositions.some((q) => q.x === x && q.y === y) &&
            !this.quantumLogicGates.some((g) => g.x === x && g.y === y) &&
            !this.snakeBody.some((s) => s.x === x && s.y === y)
          );
        }

        getRandomFreePosition() {
          while (true) {
            const randomPosition = this.getRandomPosition();
            if (this.isFreePosition(randomPosition.x, randomPosition.y)) {
              return randomPosition;
            }
          }
        }

        render(ctx) {
          ctx.save();
          this.renderQuantumLogicGates(ctx);
          ctx.restore();

          ctx.save();
          this.renderQubits(ctx);
          ctx.restore();
        }

        renderQubits(ctx) {
          ctx.lineWidth = BLOCK_SIZE;
          ctx.lineCap = "round";
          ctx.fillStyle = "white";
          ctx.font = `${BLOCK_SIZE}px sans-serif`;

          const probabilities = this.quantumCircuit.probabilities();

          this.qubitPositions.forEach(({ x: blockX, y: blockY }, i) => {
            const percentage = Math.round(probabilities[i] * 100);
            // TODO: Mix color in JS for compatibility with all browsers
            ctx.strokeStyle = `color-mix(in hsl, red ${percentage}%, green ${100 - percentage}%)`;
            ctx.beginPath();
            const x = blockX * BLOCK_SIZE + BLOCK_SIZE / 2;
            const y = blockY * BLOCK_SIZE + BLOCK_SIZE / 2;
            ctx.moveTo(x, y);
            ctx.lineTo(x, y);
            ctx.stroke();

            ctx.fillText(i, x, y);
          });
        }

        renderQuantumLogicGates(ctx) {
          ctx.lineWidth = 2;
          ctx.lineCap = "round";
          ctx.strokeStyle = "blue";
          this.quantumLogicGates.forEach(({ x: blockX, y: blockY, qubits }, i) => {
            const xStart = blockX * BLOCK_SIZE + BLOCK_SIZE / 2;
            const yStart = blockY * BLOCK_SIZE + BLOCK_SIZE / 2;

            qubits.forEach((qubit)=>{
              const xEnd = this.qubitPositions[qubit].x * BLOCK_SIZE + BLOCK_SIZE / 2;
              const yEnd = this.qubitPositions[qubit].y * BLOCK_SIZE + BLOCK_SIZE / 2;
              ctx.beginPath();
              ctx.moveTo(xStart, yStart);
              ctx.lineTo(xEnd, yEnd);
              ctx.stroke();
            });
          });

          ctx.lineWidth = BLOCK_SIZE;
          ctx.lineCap = "round";
          ctx.strokeStyle = "blue";
          ctx.fillStyle = "white";
          ctx.font = `${BLOCK_SIZE}px sans-serif`;
          this.quantumLogicGates.forEach(({ x: blockX, y: blockY, name }, i) => {
            ctx.beginPath();
            const x = blockX * BLOCK_SIZE + BLOCK_SIZE / 2;
            const y = blockY * BLOCK_SIZE + BLOCK_SIZE / 2;
            ctx.moveTo(x, y);
            ctx.lineTo(x, y);
            ctx.stroke();

            ctx.fillText(name, x, y);
          });

          
        }
      }

      function main() {
        const canvasElement = document.getElementById("gameCanvas");
        const statusElement = document.getElementById("status");

        const game = new Game(canvasElement, statusElement);
        game.start();
      }

      window.onload = main;
    </script>
    <style>
      body {
        display: flex;
        flex-direction: row;
        overflow: scroll
      }

      #status {
        margin: 10px;
      }
    </style>
  </head>

  <body>
    <div><canvas id="gameCanvas"></canvas></div>
    <div id="status"></div>
  </body>
</html>
